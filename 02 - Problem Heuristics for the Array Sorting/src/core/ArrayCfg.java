package core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayDeque;

/**
 * Represents an immutable configuration of the integer array sorting problem.
 *
 * This class implements the {@link Ilayout} interface, defining the state representation,
 * successor generation, goal checking, and heuristic estimation for the search algorithm.
 * It is designed to be immutable to ensure that states cannot be accidentally modified
 * during the search process.
 *
 * <h3>Key Implementation Details</h3>
 * <h4>Immutability</h4>
 * <p>
 * Immutability is a core design principle of this class. It is achieved by:
 * </p>
 * <ul>
 *   <li>Declaring the class as {@code final} to prevent extension.</li>
 *   <li>Making all fields {@code final}.</li>
 *   <li>Creating defensive copies of the internal array in the {@link #children()} method before modification.</li>
 * </ul>
 *
 * <h4>Successor Generation</h4>
 * <p>
 * The {@link #children()} method generates successors in a specific, deterministic order as required by the problem
 * statement: the first element is swapped with all elements to its right, then the second with all to its right, and so on.
 * </p>
 *
 * <h4>Heuristic Function (h)</h4>
 * <p>
 * This class also implements a heuristic function via the {@link #getH(Ilayout)} method,
 * which is crucial for informed search algorithms like A* ({@link AStarSearch}). The heuristic estimates the
 * remaining cost to reach the goal state. It is based on analyzing the permutation cycles
 * of the elements that are out of place, providing an admissible (never overestimating)
 * estimate of the true cost. This allows the A* algorithm to explore the search space
 * more efficiently compared to uninformed search methods like Uniform-Cost Search ({@link GSolver}).
 * </p>
 *
 * @see Ilayout
 * @see AStarSearch
 * @see GSolver
 * @see ArrayCfg
 * @author Brandon Mejia
 * @version 2024-10-15
 */
public final class ArrayCfg implements Ilayout {

    private final int[] data;
    /** The cost of the single swap that produced this state (0 for the initial state). */
    private final int cost;

    /**
     * Constructs an ArrayCfg from a space-separated string of integers.
     * This constructor is typically used for creating the initial and goal states.
     *
     * @param s The input string (e.g., "9 7 8").
     * @throws IllegalArgumentException if the input string is null or empty.
     */
    public ArrayCfg(String s)
    {
        if (s == null || s.trim().isEmpty()) {
            throw new IllegalArgumentException("Input string cannot be null or empty.");
        }
        // Split on any sequence of one or more whitespace characters for robustness.
        this.data = Arrays.stream(s.trim().split("\\s+"))
                .mapToInt(Integer::parseInt)
                .toArray();
        this.cost = 0;
    }

    /**
     * Private constructor used internally to create successor (child) states.
     *
     * @param data The new array configuration for the child.
     * @param cost The cost of the single swap that created this child state.
     */
    private ArrayCfg(int[] data, int cost) {
        this.data = data; // Assumes the caller provides a new array instance.
        this.cost = cost;
    }

    /**
     * Generates all unique successor states (children) from the current state.
     * <p>
     * The successors are generated by swapping every unique pair of integers in the array.
     * The order of generation follows the assignment's specification: the first element
     * is swapped with all elements to its right, then the second element with all elements
     * to its right, and so on.
     *
     * @return A list of child layouts. The list is unmodifiable to preserve immutability.
     */
    @Override
    public List<Ilayout> children() {
        int n = data.length;
        if (n < 2) return Collections.emptyList();

        // Pre-allocate list capacity for performance. The number of unique swaps is n*(n-1)/2.
        List<Ilayout> children = new ArrayList<>(n * (n - 1) / 2);

        // Generate all unique swaps in the specified order.
        for (int i = 0; i < n - 1; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                // Create a defensive copy of the data array to ensure the parent state remains immutable.
                int[] childData = Arrays.copyOf(data, n);

                // Perform the swap in the new child's array.
                int tmp = childData[i];
                childData[i] = childData[j];
                childData[j] = tmp;

                // Calculate the cost of this specific swap based on the parent's values.
                int swapCost = calculateCost(data[i], data[j]);

                // Create and add the new child state to the list.
                children.add(new ArrayCfg(childData, swapCost));
            }
        }

        // Return an unmodifiable view of the list to enforce immutability.
        return Collections.unmodifiableList(children);
    }

    /**
     * Calculates the cost of swapping two integers based on their parity.
     * <ul>
     *   <li>Swapping two even integers: cost 2</li>
     *   <li>Swapping two odd integers: cost 20</li>
     *   <li>Swapping one even and one odd integer: cost 11</li>
     * </ul>
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The calculated cost of the swap.
     */
    private static int calculateCost(int a, int b) {
        // Use bitwise AND for an efficient parity check that works correctly for all integers,
        // including positive, negative, and zero. An integer is even if its least significant bit is 0.
        boolean aEven = (a & 1) == 0;
        boolean bEven = (b & 1) == 0;

        if (aEven == bEven) { // Both have the same parity
            return aEven ? 2 : 20; // If aEven is true, both are even (cost 2), else both are odd (cost 20)
        } else { // Mixed parity
            return 11;
        }
    }

    /**
     * Checks if the current layout is the goal layout.
     *
     * @param l The layout to compare against.
     * @return {@code true} if the layouts are identical, {@code false} otherwise.
     */
    @Override
    public boolean isGoal(Ilayout l) {
        if (l == null || getClass() != l.getClass()) return false;
        return Arrays.equals(this.data, ((ArrayCfg) l).data);
    }

    /**
     * Gets the cost of the single step (swap) that produced this layout.
     * For the initial state, this cost is 0.
     *
     * @return The cost of the last move.
     */
    @Override
    public double getK() {
        return  this.cost;
    }

    /**
     * Calculates the heuristic value (h) for the A* algorithm.
     * <p>
     * This method delegates the complex calculation to a dedicated, private static helper class,
     * {@link Heuristic}, which implements a highly accurate and admissible heuristic based on
     * permutation cycle decomposition. This encapsulation keeps the {@code ArrayCfg} class
     * focused on representing a state, while the {@code Heuristic} class handles the
     * complex algorithmic logic.
     *
     * @see Heuristic
     */
    @Override
    public double getH(Ilayout goal) {
        if (!(goal instanceof ArrayCfg)) return Double.POSITIVE_INFINITY;
        ArrayCfg goalCfg = (ArrayCfg) goal;

        int n = data.length;
        if (goalCfg.data.length != n) return Double.POSITIVE_INFINITY;

        // Delegate to helper class
        Heuristic h = new Heuristic(this.data, goalCfg.data);
        return h.compute();
    }

    /**
     * Returns a string representation of the layout.
     * The integers are separated by a single space.
     *
     * @return A space-separated string of the array's contents.
     */
    @Override
    public String toString() {
        return Arrays.stream(data)
                .mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    /**
     * Compares this layout with another object for equality.
     * Two {@code ArrayCfg} objects are considered equal if their underlying integer arrays
     * have the same content in the same order.
     *
     * @param o The object to compare with.
     * @return {@code true} if the objects are equal, {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ArrayCfg other = (ArrayCfg) o;
        return Arrays.equals(this.data, other.data);
    }

    /**
     * Returns a hash code for this layout.
     * The hash code is based on the contents of the integer array, making it consistent
     * with the {@link #equals(Object)} method.
     *
     * @return The hash code for this layout.
     */
    @Override
    public int hashCode() {
        return Arrays.hashCode(data);
    }


    /**
         * A private helper record that encapsulates the entire heuristic calculation.
         * <p>
         * This class acts as a stateless calculator that uses a sophisticated hybrid strategy based on
         * <b>permutation decomposition into disjoint cycles</b>. The goal is to compute a very tight
         * lower-bound cost estimate for sorting the array, which makes the A* search extremely efficient.
         *
         * <h3>Heuristic Strategy</h3>
         * The permutation required to transform the current state into the goal state is decomposed into
         * cycles. For example, if the current state is {@code [2, 3, 1]} and the goal is {@code [1, 2, 3]},
         * the permutation is a single cycle {@code 1 -> 2 -> 3 -> 1}. The total heuristic cost is the
         * sum of the estimated costs to resolve each of these cycles independently.
         * <p>
         * Resolving a cycle of size {@code k} requires a minimum of {@code k-1} swaps. The strategy
         * to calculate the minimum cost to resolve a cycle varies with its size:
         * <ul>
         *   <li><b>2-element cycles (k=2):</b>
         *       A single swap resolves the cycle. The exact and optimal cost of this swap is calculated.</li>
         *   <li><b>Cycles of size k > 2:</b>
         *       A greedy and admissible
         *       strategy is applied:
         *       <ul>
         *          <li><b>If the cycle contains even numbers:</b> The cheapest strategy is to use an even
         *              number as a "pivot". The cost is the sum of {@code (number of evens - 1)} even-even
         *              swaps (cost 2) and {@code (number of odds)} even-odd swaps (cost 11).</li>
         *          <li><b>If the cycle contains only odd numbers:</b> Two options are considered:
         *              1) Resolve the cycle internally with {@code k-1} odd-odd swaps (cost 20 each).<br>
         *              2) "Borrow" an even number from outside the cycle (if one exists), perform {@code k}
         *                 even-odd swaps (cost 11 each), and then return the even number.
         *              <br>The heuristic uses the minimum cost between these two options:
         *                 {@code min((k-1)*20, k*11)}. If there are no even numbers in the array,
         *                 only the first option is possible.</li>
         *       </ul>
         *   </li>
         * </ul>
         * This approach ensures that the heuristic is always <b>admissible</b> (it never overestimates
         * the true cost), which is an essential condition for A* to find the optimal solution.
         *
         * @author Brandon Mejia
         * @see #compute()
         */
    private record Heuristic(int[] data, int[] goal)
    {

        /**
         * Computes the heuristic value by decomposing the permutation into cycles and estimating the cost.
         * <p>
         * The calculation involves these steps:
         * </p>
         * <ol>
         * <li><b>Mapping:</b> It first determines the target position for each element.</li>
         * <li><b>Cycle Decomposition:</b> The permutation is broken down into disjoint cycles.</li>
         * <li><b>Hybrid Cost Calculation:</b> The cost for resolving each cycle is estimated based on its size:
         * <ul>
         * <li><b>2-Cycles:</b> The exact cost of the single swap is calculated. This is optimal.</li>
         * <li><b>Cycles with k > 2 elements:</b> If the cycle contains an even number, it's used as a pivot. If the cycle is all-odd, the heuristic calculates the minimum cost between internal swaps and "borrowing" an external even number.</li>
         * </ul>
         * </li>
         * </ol>
         * <p>
         * This heuristic is <b>admissible</b> because it never overestimates the true cost.
         * </p>
         * <li><b>Time Complexity:</b> O(n). The cycle decomposition and cost calculation for each cycle
         *     are linear in the size of the array.</li>
         * <li><b>Space Complexity:</b> O(n). Primarily for the position map (`posMap`), the `targetIndex`
         *     array, and the `visited` array. The space for cycle lists is reused and bounded by n.</li>
         * </ul>
         */
        double compute() {
            int n = data.length;

            boolean anyEvenNumberExists = checkForAnyEvenNumber();

            Map<Integer, ArrayDeque<Integer>> posMap = buildGoalPositionMap(n);

            int[] targetIndex = buildTargetIndexArray(n, posMap);

            if (targetIndex == null)
                return Double.POSITIVE_INFINITY;


            return calculateTotalHeuristicFromCycles(targetIndex, anyEvenNumberExists);
        }

        /**
         * Checks if at least one even number exists in the initial array.
         */
        private boolean checkForAnyEvenNumber() {
            for (int val : data)
                if ((val & 1) == 0)
                    return true;

            return false;
        }

        /**
         * Builds a map from each value in the goal array to its position(s).
         */
        private Map<Integer, ArrayDeque<Integer>> buildGoalPositionMap(int n) {
            Map<Integer, ArrayDeque<Integer>> posMap = new HashMap<>(n * 2);
            for (int j = 0; j < n; j++)
                posMap.computeIfAbsent(goal[j], k -> new ArrayDeque<>()).addLast(j);

            return posMap;
        }

        /**
         * Builds an array where targetIndex[i] is the goal position of the element data[i].
         */
        private int[] buildTargetIndexArray(int n, Map<Integer, ArrayDeque<Integer>> posMap) {
            int[] targetIndex = new int[n];
            for (int i = 0; i < n; i++) {
                ArrayDeque<Integer> q = posMap.get(data[i]);
                if (q == null || q.isEmpty())
                    return null; // Indicates an invalid mapping


                targetIndex[i] = q.removeFirst();
            }
            return targetIndex;
        }

        /**
         * Decomposes the permutation into cycles and sums their individual heuristic costs.
         */
        private double calculateTotalHeuristicFromCycles(int[] targetIndex, boolean anyEvenNumberExists) {
            int n = data.length;
            boolean[] visited = new boolean[n];
            double totalHeuristic = 0.0;

            for (int i = 0; i < n; i++) {
                if (visited[i] || targetIndex[i] == i) {
                    visited[i] = true;
                    continue;
                }

                ArrayList<Integer> cycleVals = new ArrayList<>();
                ArrayList<Integer> cycleGoalVals = new ArrayList<>();
                int cur = i;
                while (!visited[cur]) {
                    visited[cur] = true;
                    cycleVals.add(data[cur]);
                    cycleGoalVals.add(goal[cur]);
                    cur = targetIndex[cur];
                }

                totalHeuristic += calculateCycleCost(cycleVals, cycleGoalVals, anyEvenNumberExists);
            }
            return totalHeuristic;
        }

        /**
         * Calculates the heuristic cost for a single cycle based on its size and content.
         */
        private double calculateCycleCost(ArrayList<Integer> cycleVals, ArrayList<Integer> cycleGoalVals, boolean anyEvenNumberExists) {
            int k = cycleVals.size();
            if (k <= 1) return 0.0;

            if (k == 2)
                return calculateCost(cycleVals.get(0), cycleVals.get(1));
            else {
                // Logic for cycles with k > 2
                int evenCount = 0;
                for (int v : cycleVals)
                    if ((v & 1) == 0) evenCount++;


                // Strategy: Use one of the cycle's even numbers as a pivot.
                if (evenCount > 0) {
                    int oddCount = k - evenCount;
                    return (long) (evenCount - 1) * 2 + (long) oddCount * 11;
                } else // All-odd cycle
                {
                    // Strategy: Compare internal swaps vs. "borrowing" an external even number.
                    if (anyEvenNumberExists)
                        return Math.min((long) (k - 1) * 20, (long) k * 11);

                        // No evens anywhere, must use odd-odd swaps.
                    else
                        return (long) (k - 1) * 20;

                }
            }
        }
    }

}
