package core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayDeque;

/**
 * Represents an immutable configuration of the integer array sorting problem.
 *
 * This class implements the {@link Ilayout} interface, defining the state representation,
 * successor generation, and goal checking for the search algorithm. It is designed to be
 * immutable to ensure that states cannot be accidentally modified during the search process.
 *
 * <h3>Key Implementation Details</h3>
 * <h4>Immutability</h4>
 * <p>
 * Immutability is a core design principle of this class. It is achieved by:
 * </p>
 * <ul>
 *   <li>Declaring the class as {@code final} to prevent extension.</li>
 *   <li>Making all fields {@code final}.</li>
 *   <li>Creating defensive copies of the internal array in the {@link #children()} method before modification.</li>
 * </ul>
 *
 * <h4>Successor Generation</h4>
 * <p>
 * The {@link #children()} method generates successors in a specific, deterministic order as required by the problem
 * statement: the first element is swapped with all elements to its right, then the second with all to its right, and so on.
 * </p>
 *
 * @see Ilayout
 * @see GSolver
 * @author Brandon Mejia
 * @version 2025-09-30
 */
public final class ArrayCfg implements Ilayout {

    private final int[] data;
    /** The cost of the single swap that produced this state (0 for the initial state). */
    private final int cost;

    /**
     * Constructs an ArrayCfg from a space-separated string of integers.
     * This constructor is typically used for creating the initial and goal states.
     *
     * @param s The input string (e.g., "9 7 8").
     * @throws IllegalArgumentException if the input string is null or empty.
     */
    public ArrayCfg(String s)
    {
        if (s == null || s.trim().isEmpty()) {
            throw new IllegalArgumentException("Input string cannot be null or empty.");
        }
        // Split on any sequence of one or more whitespace characters for robustness.
        this.data = Arrays.stream(s.trim().split("\\s+"))
                .mapToInt(Integer::parseInt)
                .toArray();
        this.cost = 0;
    }

    /**
     * Private constructor used internally to create successor (child) states.
     *
     * @param data The new array configuration for the child.
     * @param cost The cost of the single swap that created this child state.
     */
    private ArrayCfg(int[] data, int cost) {
        this.data = data; // Assumes the caller provides a new array instance.
        this.cost = cost;
    }

    /**
     * Generates all unique successor states (children) from the current state.
     * <p>
     * The successors are generated by swapping every unique pair of integers in the array.
     * The order of generation follows the assignment's specification: the first element
     * is swapped with all elements to its right, then the second element with all elements
     * to its right, and so on.
     *
     * @return A list of child layouts. The list is unmodifiable to preserve immutability.
     */
    @Override
    public List<Ilayout> children() {
        int n = data.length;
        if (n < 2) return Collections.emptyList();

        // Pre-allocate list capacity for performance. The number of unique swaps is n*(n-1)/2.
        List<Ilayout> children = new ArrayList<>(n * (n - 1) / 2);

        // Generate all unique swaps in the specified order.
        for (int i = 0; i < n - 1; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                // Create a defensive copy of the data array to ensure the parent state remains immutable.
                int[] childData = Arrays.copyOf(data, n);

                // Perform the swap in the new child's array.
                int tmp = childData[i];
                childData[i] = childData[j];
                childData[j] = tmp;

                // Calculate the cost of this specific swap based on the parent's values.
                int swapCost = calculateCost(data[i], data[j]);

                // Create and add the new child state to the list.
                children.add(new ArrayCfg(childData, swapCost));
            }
        }

        // Return an unmodifiable view of the list to enforce immutability.
        return Collections.unmodifiableList(children);
    }

    /**
     * Calculates the cost of swapping two integers based on their parity.
     * <ul>
     *   <li>Swapping two even integers: cost 2</li>
     *   <li>Swapping two odd integers: cost 20</li>
     *   <li>Swapping one even and one odd integer: cost 11</li>
     * </ul>
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The calculated cost of the swap.
     */
    private static int calculateCost(int a, int b) {
        // Explicitly define 0 as even. For other numbers, use bitwise AND for an efficient parity check
        // that works correctly for both positive and negative integers.
        boolean aEven = (a == 0) || ((a & 1) == 0);
        boolean bEven = (b == 0) || ((b & 1) == 0);

        if (aEven == bEven) { // Both have the same parity
            return aEven ? 2 : 20; // If aEven is true, both are even (cost 2), else both are odd (cost 20)
        } else { // Mixed parity
            return 11;
        }
    }

    /**
     * Checks if the current layout is the goal layout.
     *
     * @param l The layout to compare against.
     * @return {@code true} if the layouts are identical, {@code false} otherwise.
     */
    @Override
    public boolean isGoal(Ilayout l) {
        if (l == null || getClass() != l.getClass()) return false;
        return Arrays.equals(this.data, ((ArrayCfg) l).data);
    }

    /**
     * Gets the cost of the single step (swap) that produced this layout.
     * For the initial state, this cost is 0.
     *
     * @return The cost of the last move.
     */
    @Override
    public double getK() {
        return  this.cost;
    }

    /**
     * Calculates the heuristic value (h) for the A* algorithm.
     * <p>
     * This method delegates the complex calculation to a dedicated, private static helper class,
     * {@link Heuristic}, which implements a highly accurate and admissible heuristic based on
     * permutation cycle decomposition. This encapsulation keeps the {@code ArrayCfg} class
     * focused on representing a state, while the {@code Heuristic} class handles the
     * complex algorithmic logic.
     *
     * @see Heuristic
     */
    @Override
    public double getH(Ilayout goal) {
        if (!(goal instanceof ArrayCfg)) return Double.POSITIVE_INFINITY;
        ArrayCfg goalCfg = (ArrayCfg) goal;

        int n = data.length;
        if (goalCfg.data.length != n) return Double.POSITIVE_INFINITY;

        // Delegate to helper class
        Heuristic h = new Heuristic(this.data, goalCfg.data);
        return h.compute();
    }

    /**
     * Returns a string representation of the layout.
     * The integers are separated by a single space.
     *
     * @return A space-separated string of the array's contents.
     */
    @Override
    public String toString() {
        return Arrays.stream(data)
                .mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    /**
     * Compares this layout with another object for equality.
     * Two {@code ArrayCfg} objects are considered equal if their underlying integer arrays
     * have the same content in the same order.
     *
     * @param o The object to compare with.
     * @return {@code true} if the objects are equal, {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ArrayCfg other = (ArrayCfg) o;
        return Arrays.equals(this.data, other.data);
    }

    /**
     * Returns a hash code for this layout.
     * The hash code is based on the contents of the integer array, making it consistent
     * with the {@link #equals(Object)} method.
     *
     * @return The hash code for this layout.
     */
    @Override
    public int hashCode() {
        return Arrays.hashCode(data);
    }


    /**
     * A private, static helper class that encapsulates the entire heuristic calculation.
     * <p>
     * It is implemented as a stateless calculator using a sophisticated hybrid strategy based on
     * <b>permutation cycle decomposition</b>. This provides a very tight lower-bound estimate of the
     * true cost, making the A* search extremely efficient.
     *
     * @see #compute()
     */
    private static final class Heuristic
    {
        private final int[] data;
        private final int[] goal;

        Heuristic(int[] data, int[] goal) {
            this.data = data;
            this.goal = goal;
        }

        /**
         * Computes the heuristic value by decomposing the permutation into cycles and estimating the cost.
         * <p>
         * The calculation involves these steps:
         * </p>
         * <ol>
         *   <li><b>Mapping:</b> It first determines the target position for each element.</li>
         *   <li><b>Cycle Decomposition:</b> The permutation is broken down into disjoint cycles.</li>
         *   <li><b>Hybrid Cost Calculation:</b> The cost for resolving each cycle is estimated based on its size:
         *     <ul>
         *       <li><b>2-Cycles:</b> The exact cost of the single swap is calculated.</li>
         *       <li><b>Small Cycles (3-5 elements):</b> A brute-force search finds the true optimal cost.</li>
         *       <li><b>Large Cycles (>5 elements):</b> A fast, admissible greedy estimation is used.</li>
         *     </ul>
         *   </li>
         * </ol>
         * <p>
         * This heuristic is <b>admissible</b> because it never overestimates the true cost.
         * </p>
         * <ul>
         *   <li><b>Time Complexity:</b> O(n)</li>
         *   <li><b>Space Complexity:</b> O(n)</li>
         * </ul>
         */
        double compute() {
            int n = data.length;

            // 1) build posMap (goal value -> queue of positions)
            Map<Integer, ArrayDeque<Integer>> posMap = new HashMap<>(n * 2);
            for (int j = 0; j < n; j++) posMap.computeIfAbsent(goal[j], k -> new ArrayDeque<>()).addLast(j);

            // 2) build targetIndex (if multisets differ, return +inf)
            int[] targetIndex = new int[n];
            for (int i = 0; i < n; i++) {
                ArrayDeque<Integer> q = posMap.get(data[i]);
                if (q == null || q.isEmpty()) return Double.POSITIVE_INFINITY;
                targetIndex[i] = q.removeFirst();
            }

            // 3) process cycles
            boolean[] visited = new boolean[n];
            double heuristic = 0.0;

            int totalSwapsNeededFallback = 0;
            int evenRemFallback = 0;
            int oddRemFallback = 0;

            for (int i = 0; i < n; i++) {
                if (visited[i] || targetIndex[i] == i) {
                    visited[i] = true;
                    continue;
                }

                int cur = i;
                ArrayList<Integer> cycleVals = new ArrayList<>();
                ArrayList<Integer> cycleGoalVals = new ArrayList<>();

                while (!visited[cur]) {
                    visited[cur] = true;
                    cycleVals.add(data[cur]);
                    cycleGoalVals.add(goal[cur]);
                    cur = targetIndex[cur];
                }

                int k = cycleVals.size();
                if (k <= 1) continue;

                if (k == 2) {
                    heuristic += calculateCost(cycleVals.get(0), cycleVals.get(1));
                } else if (k <= 5) {
                    heuristic += costForSmallCycle(cycleVals, cycleGoalVals);
                } else {
                    int evenCount = 0, oddCount = 0;
                    for (int v : cycleVals) {
                        boolean ev = (v == 0) || ((v & 1) == 0);
                        if (ev) evenCount++; else oddCount++;
                    }
                    totalSwapsNeededFallback += (k - 1);
                    evenRemFallback += evenCount;
                    oddRemFallback += oddCount;
                }
            }

            // 4) apply greedy fallback for aggregated large cycles
            heuristic += greedyCostForFallback(totalSwapsNeededFallback, evenRemFallback, oddRemFallback);
            return heuristic;
        }

        /**
         * Finds the minimal cost to resolve a small cycle by brute-forcing all valid swap sequences.
         * A sequence is valid if it consists of exactly (k-1) swaps and sorts the cycle.
         * Assumes k is in [3..5]. Uses pruning to discard non-optimal paths early.
         */
        private static double costForSmallCycle(List<Integer> cycleVals, List<Integer> cycleGoalVals) {
            final int k = cycleVals.size();
            // build pair list of unordered index pairs
            ArrayList<int[]> pairList = new ArrayList<>();
            for (int a = 0; a < k - 1; a++) {
                for (int b = a + 1; b < k; b++) {
                    pairList.add(new int[]{a, b});
                }
            }

            int steps = k - 1;
            int base = pairList.size();
            long sequences = 1;
            for (int s = 0; s < steps; s++) sequences *= base; // <= 10_000 for k=5

            double bestCost = Double.POSITIVE_INFINITY;
            int[] idx = new int[steps];

            outer:
            for (long seq = 0; seq < sequences; seq++) {
                int[] curVals = new int[k];
                for (int t = 0; t < k; t++) curVals[t] = cycleVals.get(t);

                double costSum = 0.0;
                for (int step = 0; step < steps; step++) {
                    int pairIndex = idx[step];
                    int p = pairList.get(pairIndex)[0];
                    int q = pairList.get(pairIndex)[1];

                    int va = curVals[p], vb = curVals[q];
                    costSum += calculateCost(va, vb);

                    // swap
                    int tmp = curVals[p]; curVals[p] = curVals[q]; curVals[q] = tmp;

                    if (costSum >= bestCost) {
                        // increment index and continue outer loop (prune)
                        for (int pidx = steps - 1; pidx >= 0; pidx--) {
                            idx[pidx]++;
                            if (idx[pidx] < base) break;
                            idx[pidx] = 0;
                        }
                        continue outer;
                    }
                }

                // check match
                boolean matches = true;
                for (int t = 0; t < k; t++) {
                    if (curVals[t] != cycleGoalVals.get(t)) { matches = false; break; }
                }
                if (matches && costSum < bestCost) bestCost = costSum;

                // increment index
                for (int pidx = steps - 1; pidx >= 0; pidx--) {
                    idx[pidx]++;
                    if (idx[pidx] < base) break;
                    idx[pidx] = 0;
                }
            }

            if (bestCost == Double.POSITIVE_INFINITY) {
                // fallback greedy pairing (very rare)
                int even = 0, odd = 0;
                for (int v : cycleVals) { if ((v == 0) || ((v & 1) == 0)) even++; else odd++; }
                int swapsNeeded = k - 1;
                double sum = 0;
                for (int s = 0; s < swapsNeeded; s++) {
                    if (even >= 2) { sum += 2; even -= 2; }
                    else if (even >= 1 && odd >= 1) { sum += 11; even -= 1; odd -= 1; }
                    else if (odd >= 2) { sum += 20; odd -= 2; }
                    else break;
                }
                return sum;
            }

            return bestCost;
        }

        /**
         * Estimates the cost for large cycles using a greedy approach.
         * It repeatedly simulates the cheapest possible swap (even-even, then mixed, then odd-odd)
         * based on the available counts of even and odd numbers.
         */
        private static double greedyCostForFallback(int swapsNeeded, int evenCount, int oddCount) {
            double cost = 0.0;
            for (int s = 0; s < swapsNeeded; s++) {
                if (evenCount >= 2) {
                    cost += 2; evenCount -= 2;
                } else if (evenCount >= 1 && oddCount >= 1) {
                    cost += 11; evenCount -= 1; oddCount -= 1;
                } else if (oddCount >= 2) {
                    cost += 20; oddCount -= 2;
                } else {
                    break; // conservative
                }
            }
            return cost;
        }
    } 

}
