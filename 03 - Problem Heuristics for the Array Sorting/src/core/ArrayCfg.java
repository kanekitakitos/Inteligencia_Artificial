package core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents an immutable configuration of the integer array sorting problem.
 *
 * This class implements the {@link Ilayout} interface, defining the state representation,
 * successor generation, and goal checking for the search algorithm. It is designed to be
 * immutable to ensure that states cannot be accidentally modified during the search process.
 *
 * <h3>Key Implementation Details</h3>
 * <h4>Immutability</h4>
 * <p>
 * Immutability is a core design principle of this class. It is achieved by:
 * </p>
 * <ul>
 *   <li>Declaring the class as {@code final} to prevent extension.</li>
 *   <li>Making all fields {@code final}.</li>
 *   <li>Creating defensive copies of the internal array in the {@link #children()} method before modification.</li>
 * </ul>
 *
 * <h4>Successor Generation</h4>
 * <p>
 * The {@link #children()} method generates successors in a specific, deterministic order as required by the problem
 * statement: the first element is swapped with all elements to its right, then the second with all to its right, and so on.
 * </p>
 *
 * @see Ilayout
 * @see GSolver
 * @author Brandon Mejia
 * @version 2025-09-30
 */
public final class ArrayCfg implements Ilayout {

    private final int[] data;
    /** The cost of the single swap that produced this state (0 for the initial state). */
    private final int cost;

    /**
     * Constructs an ArrayCfg from a space-separated string of integers.
     * This constructor is typically used for creating the initial and goal states.
     *
     * @param s The input string (e.g., "9 7 8").
     * @throws IllegalArgumentException if the input string is null or empty.
     */
    public ArrayCfg(String s)
    {
        if (s == null || s.trim().isEmpty()) {
            throw new IllegalArgumentException("Input string cannot be null or empty.");
        }
        // Split on any sequence of one or more whitespace characters for robustness.
        this.data = Arrays.stream(s.trim().split("\\s+"))
                .mapToInt(Integer::parseInt)
                .toArray();
        this.cost = 0;
    }

    /**
     * Private constructor used internally to create successor (child) states.
     *
     * @param data The new array configuration for the child.
     * @param cost The cost of the single swap that created this child state.
     */
    private ArrayCfg(int[] data, int cost) {
        this.data = data; // Assumes the caller provides a new array instance.
        this.cost = cost;
    }

    /**
     * Generates all unique successor states (children) from the current state.
     * <p>
     * The successors are generated by swapping every unique pair of integers in the array.
     * The order of generation follows the assignment's specification: the first element
     * is swapped with all elements to its right, then the second element with all elements
     * to its right, and so on.
     *
     * @return A list of child layouts. The list is unmodifiable to preserve immutability.
     */
    @Override
    public List<Ilayout> children() {
        int n = data.length;
        if (n < 2) return Collections.emptyList();

        // Pre-allocate list capacity for performance. The number of unique swaps is n*(n-1)/2.
        List<Ilayout> children = new ArrayList<>(n * (n - 1) / 2);

        // Generate all unique swaps in the specified order.
        for (int i = 0; i < n - 1; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                // Create a defensive copy of the data array to ensure the parent state remains immutable.
                int[] childData = Arrays.copyOf(data, n);

                // Perform the swap in the new child's array.
                int tmp = childData[i];
                childData[i] = childData[j];
                childData[j] = tmp;

                // Calculate the cost of this specific swap based on the parent's values.
                int swapCost = calculateCost(data[i], data[j]);

                // Create and add the new child state to the list.
                children.add(new ArrayCfg(childData, swapCost));
            }
        }

        // Return an unmodifiable view of the list to enforce immutability.
        return Collections.unmodifiableList(children);
    }

    /**
     * Calculates the cost of swapping two integers based on their parity.
     * <ul>
     *   <li>Swapping two even integers: cost 2</li>
     *   <li>Swapping two odd integers: cost 20</li>
     *   <li>Swapping one even and one odd integer: cost 11</li>
     * </ul>
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The calculated cost of the swap.
     */
    private static int calculateCost(int a, int b) {
        // Explicitly define 0 as even. For other numbers, use bitwise AND for an efficient parity check
        // that works correctly for both positive and negative integers.
        boolean aEven = (a == 0) || ((a & 1) == 0);
        boolean bEven = (b == 0) || ((b & 1) == 0);

        if (aEven == bEven) { // Both have the same parity
            return aEven ? 2 : 20; // If aEven is true, both are even (cost 2), else both are odd (cost 20)
        } else { // Mixed parity
            return 11;
        }
    }

    /**
     * Checks if the current layout is the goal layout.
     *
     * @param l The layout to compare against.
     * @return {@code true} if the layouts are identical, {@code false} otherwise.
     */
    @Override
    public boolean isGoal(Ilayout l) {
        if (l == null || getClass() != l.getClass()) return false;
        return Arrays.equals(this.data, ((ArrayCfg) l).data);
    }

    /**
     * Gets the cost of the single step (swap) that produced this layout.
     * For the initial state, this cost is 0.
     *
     * @return The cost of the last move.
     */
    @Override
    public double getK() {
        return  this.cost;
    }

    /**
     * Calculates the heuristic value (h) for the A* algorithm.
     * <p>
     * This is a highly accurate and admissible heuristic based on the mathematical concept of
     * <b>permutation cycle decomposition</b>. It provides a very tight lower-bound estimate of
     * the minimum cost to sort the array, making the A* search extremely efficient.
     * The calculation involves these steps:
     * </p>
     * <ol>
     *   <li><b>Mapping:</b> It first determines the target position for each element in the current
     *       layout relative to the goal layout, correctly handling duplicate numbers.</li>
     *   <li><b>Cycle Decomposition:</b> The permutation is broken down into disjoint cycles. For example,
     *       if element `A` is in `B`'s spot, `B` in `C`'s spot, and `C` in `A`'s spot, they form a 3-cycle.</li>
     *   <li><b>Cost Calculation for 2-Cycles:</b> For cycles of length 2 (a simple swap), the exact
     *       cost of that one swap is calculated and added to the total heuristic value.</li>
     *   <li><b>Cost Estimation for Larger Cycles:</b> A cycle of length `k > 2` requires `k-1` swaps to be resolved.
     *       The elements from all such larger cycles are pooled together. A greedy algorithm then estimates
     *       the minimum cost to perform the required number of swaps by always choosing the cheapest
     *       pairing available (even-even, then mixed-parity, then odd-odd).</li>
     * </ol>
     * <p>
     * This heuristic remains admissible because it calculates exact costs for 2-cycles and uses a
     * best-case greedy strategy for all other required swaps, ensuring it never overestimates the true cost.
     * </p>
     * <ul>
     *     <li><b>Time Complexity:</b> O(n), where n is the number of elements in the array. Each step
     *     (mapping, cycle decomposition, greedy pairing) is linear.</li>
     *     <li><b>Space Complexity:</b> O(n), due to the storage required for the position maps and visited arrays.</li>
     * </ul>
     *
     * @param goal The goal layout to compare against.
     * @return The estimated cost to reach the goal.
     */
    @Override
    public double getH(Ilayout goal) {
        if (!(goal instanceof ArrayCfg)) return Double.POSITIVE_INFINITY;
        ArrayCfg goalCfg = (ArrayCfg) goal;

        int n = data.length;
        if (goalCfg.data.length != n) return Double.POSITIVE_INFINITY;

        // 1) Map each value to a queue of goal positions (handles duplicates)
        java.util.Map<Integer, java.util.ArrayDeque<Integer>> posMap = new java.util.HashMap<>();
        for (int j = 0; j < n; j++) {
            posMap.computeIfAbsent(goalCfg.data[j], k -> new java.util.ArrayDeque<>()).addLast(j);
        }

        // 2) Build targetIndex: where should element at i go in goal?
        int[] targetIndex = new int[n];
        for (int i = 0; i < n; i++) {
            java.util.ArrayDeque<Integer> q = posMap.get(data[i]);
            if (q == null || q.isEmpty()) {
                // multisets differ -> unreachable / invalid goal mapping
                return Double.POSITIVE_INFINITY;
            }
            targetIndex[i] = q.removeFirst();
        }

        // 3) Decompose permutation into cycles
        boolean[] visited = new boolean[n];
        int totalSwapsNeeded = 0;

        // We'll accumulate parity counts for cycles of len > 2.
        int evenRem = 0;
        int oddRem = 0;
        double heuristic = 0.0;

        for (int i = 0; i < n; i++) {
            if (visited[i] || targetIndex[i] == i) {
                visited[i] = true;
                continue;
            }

            // follow cycle starting at i
            int cur = i;
            java.util.ArrayList<Integer> cycleVals = new java.util.ArrayList<>();
            while (!visited[cur]) {
                visited[cur] = true;
                cycleVals.add(data[cur]);
                cur = targetIndex[cur];
            }

            int len = cycleVals.size();
            if (len <= 1) continue;

            if (len == 2) {
                // For 2-cycles we know exactly one swap needed: use exact cost of swapping these two values.
                int a = cycleVals.get(0);
                int b = cycleVals.get(1);
                heuristic += calculateCost(a, b);
                // this 1 swap is already accounted for; do not add to remaining counts
            } else {
                // For cycles length > 2 we need len-1 swaps, but the exact cheapest combination is harder.
                // We'll add (len - 1) to totalSwapsNeeded and collect their parities to be greedily paired later.
                totalSwapsNeeded += (len - 1);
                for (int v : cycleVals) {
                    boolean ev = (v == 0) || ((v & 1) == 0);
                    if (ev) evenRem++; else oddRem++;
                }
            }
        }

        // 4) Greedy pairing to estimate minimal cost for the remaining swapsNeeded
        // Each swap consumes two elements, choose cheapest available pair each time.
        for (int s = 0; s < totalSwapsNeeded; s++) {
            if (evenRem >= 2) {
                heuristic += 2; // even-even
                evenRem -= 2;
            } else if (evenRem >= 1 && oddRem >= 1) {
                heuristic += 11; // mixed
                evenRem -= 1;
                oddRem -= 1;
            } else if (oddRem >= 2) {
                heuristic += 20; // odd-odd
                oddRem -= 2;
            } else {
                // If we run out of elements (shouldn't happen), be conservative and break.
                break;
            }
        }

        return heuristic;
    }

    /**
     * Returns a string representation of the layout.
     * The integers are separated by a single space.
     *
     * @return A space-separated string of the array's contents.
     */
    @Override
    public String toString() {
        return Arrays.stream(data)
                .mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    /**
     * Compares this layout with another object for equality.
     * Two {@code ArrayCfg} objects are considered equal if their underlying integer arrays
     * have the same content in the same order.
     *
     * @param o The object to compare with.
     * @return {@code true} if the objects are equal, {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ArrayCfg other = (ArrayCfg) o;
        return Arrays.equals(this.data, other.data);
    }

    /**
     * Returns a hash code for this layout.
     * The hash code is based on the contents of the integer array, making it consistent
     * with the {@link #equals(Object)} method.
     *
     * @return The hash code for this layout.
     */
    @Override
    public int hashCode() {
        return Arrays.hashCode(data);
    }
}
